# oauth2.py
from datetime import datetime, timedelta
from jose import JWTError, jwt
from . import schemas, database, models
from fastapi import Depends, status, HTTPException
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from .config import settings


# In real projects, store this in environment variables!
SECRET_KEY = settings.secret_key
ALGORITHM = settings.algorithm
ACCESS_TOKEN_EXPIRE_MINUTES = settings.access_token_expire_minutes

# whatever data we want to encode into the token we have to provide that "data"
# takes a dictionary, adds expiration time to it, signs it with your SECRET_KEY, 
# returns a JWT token string
def create_access_token(data: dict):
    """
    # Create a JWT access token

    data: a dict of data you want to encode into the token (e.g., {"user_id": 1})
    returns: a JWT string
    """
    to_encode = data.copy()

    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})  # 'exp' = expiration claim
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    # produces a token like:
    # header.payload.signature(header + payload + secret key)
    # header contains basic info
    # the payload contains basic information such as userid and expiration
    # the signature (this is where the SECRET_KEY is used) takes the header + payload + secret key and outputs a signature which is then used in the above
    # so basically the signature is generated by hashing together the header, payload, and the secret key, and this signature becomes the third part of the JWT
    return encoded_jwt



def verify_access_token(token: str, credentials_exception):
    try:
        # if the signature is valid, the function successfully decodes the token and returns the payload -> a python dictionary containing the data originally embedded in the token
        # the jwt.decode function first takes the Header and Payload from the incoming token string
        # takes your locally stored SECRET_KEY and the specified ALGORITHM
        # it then re-creates the signature using the original Header, Payload, and your secret key
        # it compares the signature it just created with the Signatue that was attached to the incoming JWT string
        # if they match, the token is proven to be authentic and untampered, and the function proceeds
        # Once the signature is verified, the functions final actgion is to simply decode the Payload from its Base64 format back into a standard Python dictionary
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        id: str = payload.get("user_id")

        if id is None:
            raise credentials_exception
        #Put the important part into TokenData
        token_data = schemas.TokenData(id=id) 
        return token_data # if successful, returns the Pydantic model containing the verified identity, specifically the user ID
    except JWTError:
        raise credentials_exception
    

oauth2_scheme = OAuth2PasswordBearer(tokenUrl='login') # you are creating a tool -> find the JWT token inside the request header
# basically looks at the incomming HTTP request
# finds the Authorization header and extracts just the token part
# It does NOT decode the token, it does NOT verify the token, it does NOT check expiration
# it ONLY extracts the token string from the incoming request
# Think of oauth2_scheme as a token picker

# before running this function, run oauth2_scheme and whatever it returns, put it into the variable 'token'
# so now token becomes the raw JWT token string from the request
# The JWT token comes from YOUR login route. You create it, You return it to the user, Then the user sends it back in the Authorization header
def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(database.get_db)):
    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=f"Could Not Validate Credentials", headers={"WWW-Authenticate": "Bearer"})

    token = verify_access_token(token, credentials_exception)
    # find the user whose ID matches the ID inside the token (find the user in the database)
    user = db.query(models.User).filter(models.User.id == token.id).first()


    return user     # FastAPI injects this returned object into you route

# Think of get_current_user() as 
    # Read Token
    # Validate Token
    # Load User
    # Allow request through
